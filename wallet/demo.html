<script>

log = (where, act)=>{
  window[where].innerHTML += `<p>${act}</p>`
}

l=console.log

FairDemo = (users, ch, trans, times, tag)=>{
  //style="height:430px;font-size:24px"
  var render = function () {
    var html = ''
    for (var id in ch) {
      var u = ch[id]

      var r = resolveChannel(u[2], u[3])
      var bar = fill('○', r.promised) + fill('●', r.insured) + fill('●', r.they_insured) + fill('○', r.they_promised)

      var insert_at = u[3] + r.promised

      bar = bar.slice(0, insert_at) + fill(' ', 30-bar.length) + bar.slice(insert_at)

      html += '<b>'+pad(users[u[0]][0], 10)+'</b> ' + bar + ' '+ pad(users[u[1]][0], 10)+"\n"
    }
    tag.innerHTML = '<pre>'+html+'</pre>'
  }

  var clone = JSON.stringify(ch)

  var i = 0
  setInterval(()=>{
    i++
    if (i == times + 10) {
      ch = JSON.parse(clone)
      i = 0
    } else if (i<=times) {
      trans(ch)
    }

    render()
  }, 200)



}


pad=(str, len)=>str.toString().padEnd(len, ' ')

fill=(symbol, len)=>Array(len+1).join(symbol)

resolveChannel = (insurance, delta, is_left=true) => {
  var parts = {
    // left user promises only with negative delta, scenario 3
    promised: delta < 0 ? -delta : 0,
    insured:      delta > insurance ? insurance : (delta > 0 ? delta             : 0),
    they_insured: delta > insurance ? 0         : (delta > 0 ? insurance - delta : insurance),
    // right user promises when delta goes beyond insurance, scenario 1
    they_promised: delta > insurance ? delta - insurance : 0
  }
  
  // default view is left. if current user is right, simply reverse
  if (!is_left) {
    [parts.promised, parts.insured, parts.they_insured, parts.they_promised] = 
    [parts.they_promised, parts.they_insured, parts.insured, parts.promised]
  }

  return parts
}



send = (from, to, amount=1)=>{
  if (amount > 1) {
    log('off',users[from][0]+' sends $'+amount+' to '+users[to][0]+' via hub')

    for (i=0;i<amount;i++){
      setTimeout(()=>{
        send(from, to, 1)
      },100*i)
    }

  } else {
    ch[from][1] -= amount
    ch[to][1] += amount
  }

}


slowmo = (cb, times)=>{
  for (i=0;i<times;i++){
    setTimeout(()=>{
      cb()
    },80*i)
  }
}

window.onload=()=>{

FairDemo([
  ['Hub', 10],
  ['Alice', 15],
  ['Bob', 15],
  ['Shop', 15],
  ['Creditor',20]
], [
  [1, 0, 10, 10],
  [2, 0, 10, 10],
  [3, 0, 10, 10]
],(ch)=>{
  ch[0][3]--
  ch[1][3]++
}, 5, asc)



FairDemo([
  ['Hub', 10],
  ['Alice', 15],
  ['Bob', 15],
  ['Shop', 15],
  ['Creditor',20]
], [
  [1, 0, 10, 5],
  [2, 0, 10, 15],
  [3, 0, 10, 10]
],(ch)=>{
  ch[0][3]--
  ch[1][3]++
}, 5, asc2)



}

</script>


<div id=asc></div>
<div id=asc2></div>
<div id=asc3></div>

<center> <button onclick="steps.shift()()">Next Slide</button> </center>
<br><br>

<div style="font-size:24px; padding:40px" id=info>This is a dead simple and, hopefully, obvious visual demonstration of payment channels. We'll show how LN works, demonstrate the liquidity problem and propose a simple solution to it. Below every user you will see their global on-chain balance (Alice, Bob, Carol and Hub have 15 coins each, creditor has 20). Moving those is slow as it requires public broadcast, so let's create a payment channel.</div>

<br><br>

<div style="float:left; padding: 40px" width="50%"><b>Off-chain events (processed between participating nodes only)</b>
<div id=off></div>
</div>
<div  style="float:right; padding: 40px" width="50%"><b>On-chain events (must be processed on every node)</b>
<div id=on></div>

</div>


